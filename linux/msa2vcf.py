#!/usr/bin/python

"""
msa2vcf.py

This code is python version of converting MSA(multiple sequence alignment) to
VCF (variant call format)

Author : Sunghoon Heo
"""

from SequenceParser import FAParser
from collections import Counter

class Msa2Vcf(object):
	def __init__(self, mafft_alignment , vcf_output):
		self.mafft_name = mafft_alignment
		self.output = vcf_output
		self.chrom = "chrUn"
	def execute(self):
		self.open_streams()
		header = self.gen_header()

		self.vcf.write(header)

		store = self._store_aln_data()

		seqs = self._select_seqs(store)
		#ids = self._select_ids()

		seq_mat = self._build_sequence_matrix(seqs)

		rows , cols = self._get_matrix_shape(seq_mat)
#		print rows , cols
		colidx = 0
		while colidx < cols:
#			print "Current column searching : " , colidx
			col_bases = self._get_column_bases(seq_mat, colidx)
			n = self._get_num_diff_base_in_a_col(col_bases)

			if n == 1 : 
				colidx += 1
				continue ### Not interesting

			### Okay we observed variants
			if not self._is_dash_in_column(col_bases):
				### Normal substitution
				variants = self._get_unique_bases_in_a_col(col_bases)
				ref = variants[0]
				alts = ",".join(variants[1:])
				pos = colidx
				info = [ self.chrom , str(pos),"." , ref,alts]
				self._flush_vcf(info)
				colidx += 1
				continue

			### Wow indel!!!!

			flag_points = self._stride_until_no_dash(colidx, seq_mat)
			squeezed_flag_points = self._squeeze_flag_points(flag_points)
			for end , flag in sequeezed_flag_points:
				ref = "S"
				if flag == "I":
					### Only I know this shit
					alt="I"
				else:
					alt = "D"
				pos=  end
				info = [ self.chrom , str(pos) , "." , ref, alt]
				self._flush_vcf(info)
			colidx += end
		self.close_streams()
	def open_streams(self):
		self.mafft_parser = FAParser(self.mafft_name)
		self.vcf = open(self.output , "w")
		self.mafft_parser.open()
	def close_streams(self):
		self.mafft_parser.close()
		self.vcf.close()
		
	def gen_header(self):
		header = "###VCF\n###Generated By TnClone\n###This is TnClone specific VCF format\n#CHROM\tPOS\tID\tREF\tALT\n"
		return header

	def _store_aln_data(self):
		store = []
		for id , desc , seq in self.mafft_parser.parse():
			store.append((id , seq))
		return store

	def _select_seqs(self, store):
		return map(lambda x : x[1] , store)

	def _select_ids(self, store):
		return map(lambda x : x[0] , store)

	
	def _build_sequence_matrix(self, sequence_set):
		mat = []
		for seq in sequence_set:
			mat.append(list(seq))
		return mat

	def _get_matrix_shape(self, mat):
		rows = len(mat)
		cols = len(mat[0])
		return rows , cols
	def _get_column_bases(self, seq_mat, idx):
		rows , cols = self._get_matrix_shape(seq_mat)
		assert id > cols , "Invalid index for column"
		bases = []
		for i in range(rows) :
			row = seq_mat[i]
			base = row[idx]
			bases.append(base)
		return bases
	def _get_unique_bases_in_a_col(self, col_bases):
		C = Counter(col_bases)
		DC = dict(C)
		B = []
		for k , v in DC.items():
			B.append(k)
		return B

	def _get_num_diff_base_in_a_col(self, col_bases):
		C = Counter(col_bases)
		N = len(C)
		return N

	def _is_dash_in_column(self, col_bases):
		return '-' in col_bases

	def _count_number_dash(self, col_bases):
		cnt = 0
		for b in col_bases:
			if b == '-': cnt += 1
		return cnt

	def _stride_until_no_dash(self , start_index , seq_mat):

		### This will generate indel regions

		col_bases = self._get_column_bases(seq_mat, start_index)
		end = start_index
		flag = None
		flag_points = []
		while True:
			start_index += 1
			col_bases = self._get_column_bases(seq_mat , start_index)
			
			if self._is_dash_in_column(col_bases):
				n_dash = self.count_number_dash(col_bases)
				end = start_index
				if n_dash > len(col_bases) / 2:
					### Majority are dashes. Insertion
					flag = "I"
				else:
					flag = "D"
				flag_points.append((end , flag))
			else:
				break
		return flag_points

	def _squeeze_flag_points(self, flag_points):
		if len(flag_points) == 1:
			return flag_points

		new_one = []
		idx , flag = flag_points[0]
		for enum_i , t  in enumerate(flag_points[1:]):
			if flag != t[1]:
				T = flag_points[1:][enum_i-1]
				new_one.append(T)
				break

			else:
				continue
		idx , flag = t
		acc = enum_i + 1
		while acc != len(flag_points[1:]):
			t = flag_points[1:][enum_i]
			if t[1] != flag:
				new_one.append(t)
			else:
				enum_i += 1
				acc = enum_i + 1

		return new_one

	def _flush_vcf(self , info):
		### Info must contain format required
		s= "\t".join(info)
		self.vcf.write(s + "\n")


## Test code

if __name__ == "__main__":
	aln_fname = "./test.mafft"
	vcf_fname = "./test.mafft.vcf.txt"
	converter = Msa2Vcf(aln_fname , vcf_fname)
	converter.execute()
